

# 程序是怎样跑起来的？

[TOC] 



## 虚拟内存出现之前

先来看看在操作系统还没有支持分段以及分页，以及虚拟内存技术的时候，程序是如何运行起来的，我以 C 代码举例，其它编程语言也是类似的。

```c
1. 编写程序
    
int main(){
    // 代码
    
    return 0;
}

2.编译成机器代码，这里以伪汇编代码作为展示
 .text
 _entry: //入口地址
    call _main
    call _exit
 _main:
   ...
       
 --------------------------------
       函数名其实可以理解为地址
 --------------------------------
 .text
 	_entry: //入口地址
      call 40
      call 50
 _main:  // _main 偏移是 40
   ...   
```

3.将程序载入内存

![image-20220619224634820](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220619224634820.png)

其实上面所说的程序的运行方式其实类似于单片机，也就是说只能运行一个程序。

那问题来了，如何让计算机可以运行更多的程序呢？其实后面要提到的分段，分页，以及虚存技术都是为了解决如何让计算机高效运行更多程序的问题的。



那我们先来自己想下怎样才能让操作系统同时运行更多的程序？

很容易想到的一个方法是：让操作系统为每个进程分配它们各自所需的物理内存。

**如图所示：**

![image-20220620001122386](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220620001122386.png)



上图展示了为一个进程分配物理内存的情况，如果是多个进程同时运行的话，操作系统就必须为每个进程分配物理内存，而这样的话，每个进程就分别拥有自己的内存空间，而这个内存空间的起始地址，也叫基地址。这样操作系统就可以根据进程各自的基地址将程序加载至对应的物理内存中。

但是，这样也是存在问题的？

cpu 执行的第一条指令应该是 call 1040 ，而不是call 40，因为40属于逻辑地址(相对地址)，必须进行重定位形成物理地址，即：用段的基址+段内偏移(1000+40) => 物理地址，这个重定位过程一般都是由硬件( CPU )来完成的。



上面所说的方式其实就是所谓的分段。分段的具体细节我们下面再讲。



**总结一下：多个程序要想同时运行起来，得有以下几个步骤：**

- 操作系统得创建进程，即创建 PCB

- 在物理内存找空闲内存，将这个空闲内存的起始地址(程序的基地址)保存在 各自进程的 PCB 中

- 将编译好的二进制程序存放在上面的空闲内存中

- cpu 不断的进行取指-执行，取指-执行。（在取指的时候，cpu先拿到的是逻辑地址，也就是相对地址，必须要进行运行时的重定位，即：cpu从基址寄存器中拿到空闲内存的起始地址(基地址)，要通过运算得到物理地址，才能进行真正的访存）

  

**各位要注意：** 上述举的例子，操作系统在将可执行程序加载至内存的时候是以整个程序为单位的。



## 内存不够用怎么办？

我们的期望是操作系统上能够运行更多的程序，但是早期的操作系统受到硬件资源的限制(比如：物理内存比较小而且昂贵，不支持有效的内存管理机制)，这就限制了操作系统不能同时运行更多的程序，当时出现了覆盖和交换技术，有效地解决了内存不够的情况。 

###  覆盖

1. 把某一个程序按照其自身逻辑结构，划分为若干个功能上相对独立的程序模块，那些不会同时执行的模块共享同一块内存区域，按时间先后来运行。程序员也需要编写一个小的程序来管理这些模块何时应该驻留内存而合适应该被替换掉。这个小的程序就是所谓的**覆盖管理器(Overlay Manager)**

2. 覆盖的简单图示：

   a：假设可用的物理内存只有1536k, 而该应用程序总大小为 1024K + 512K + 256K = 1792K,并且 main 函数和模块 B 和模块 C存在调用关系，即：main 函数里调用了 函数 B 和 函数 C，而 B 和 C 之间不存在函数调用关系。

   b: 而一般情况下，main 函数的代码是常驻内存的，这样模块 B 和 C 就可以共享剩下的 512k ，有效的解决了物理内存不足的问题。

   c: 覆盖是针对单个程序来说的。而且程序中所有的函数的调用关系形成一个调用链，如 main -> func1 ->func2 -> func3, 如果形成一个调用链，是没有办法节省物理内存的。可执行程序有多大，物理内存就必须有多大。

   ![image-20220806232131214](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220806232131214.png)

   

3. 覆盖的缺点：

   - 由程序员来把一个大的程序划分为若干个小的功能模块，并确定各个模块之间的覆盖关系，费时费力，增加了编程的难度。

   - 覆盖模块从磁盘装入内存，实际上是以时间延长来换取空间的节省。

     

### 交换

1. 将暂时不能运行的程序换出到磁盘，将要运行的程序换入到内存，交换是以整个程序为单位的。

2. 简单图示：

   ![image-20220628213404695](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220628213404695.png)






### 分段和分页的引入

首先说明的一点是，我们大学学习的操作系统，都是讲的是 Intel x86 CPU 架构下的分段式内存管理和分页式内存管理，所以我讲的也是这种架构下的。

在没有支持分段和分页的时候，计算机只能运行一个程序，类似于单片机，上面也有提到过。

但是我们的操作系统希望在有限的物理内存运行更多的程序，那怎么办呢？

#### 简单的内存分配策略

在谈分段和分页之前，我们先来看一种简单的内存分配策略。

假设我们的计算机的物理内存100MB的物理内存，程序 A 运行需要 10MB，程序 B 运行需要80MB，程序 C 运行需要 20MB，如果我们要同时运行程序 A 和 B,  那么我们可以想到一个最简单的内存分配方式： 将物理内存的前 10 M分配给程序A，10M ~ 90M分配给程序 B,这样就能够实现程序 A 和程序 B同时运行。但这种简单的内存分配策略问题很多，比如下面的这几个：

- **地址空间不隔离**：所有程序都直接访问物理地址，程序所使用的内存空间都不是相互隔离的。恶意的程序可以很容易的改写其它程序的内存数据，这会使得其它程序崩溃。
- **内存使用效率低：** 
  1. 换入和换出还是以整个程序为单位，还是以时间延长来换取空间的节省，换入换出的工作是由操作系统来完成的，程序员不需要关心。
  2. 正是因为装载程序至物理内存是以整个程序为单位的，这就造成了给每个程序分配物理内存的时候，都是分配一个连续的物理内存区域，而这种方式有明显的缺点，即：对内存的使用效率比较低，容易产生内存碎片(外碎片)。
- **程序运行的地址不确定：** 因为程序每次载入内存运行时，我们都需要给它从物理内存中分配足够的内存，而且这个内存区域的位置是不确定的。这给程序的编写造成了一定的困难，因为程序在编写时，它访问数据和指令的地址都是固定的，每次重新载入程序时，数据和指令的地址都会改变。



![image-20220809232200827](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220809232200827.png)



随着计算机硬件的发展，使得硬件支持了分段和分页

#### 分段

我们先来看下分段是为了解决什么的？

上面谈到的简单的内存分配策略其实属于连续内存分配， 何为连续内存分配？ 其实就是分配给程序的内存是一块连续的物理内存区域，如上图所示，这种连续内存分配方式的缺点上面也提到过，这里就不说了。

其实分段解决的就是上述连续内存分配的三个缺点，接下来我们来谈下分段机制是如何解决这几个问题的。



1.我们编写的程序经过编译器编译之后，会生成可执行程序，而这个可执行程序会包括数据段(.data)，代码段(.text)，等其它段。

- 引入了分段机制之后，用户程序使用的逻辑地址分为两部分，一部分用来表示段号， 另一部分表示段内偏移。

- 分段的简单图示：

![image-20220702093816850](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220702093816850.png)



- 下面我将用一个图来说明硬件是如何支持分段的？

  ![image-20220702125427115](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220702125427115.png)



**分段的优点：**

- 首先是解决了各个程序地址空间不隔离的问题，大家可以先想想是怎么解决的？

  假设有两个程序( A 和 B )要同时运行，操作系统在装载这两个可执行程序的时候，首先要给这两个进程分配物理内存，从而建立段表，这两个进程分别有它们各自的段表，有了段表之后，即使程序 A 和程序 B拥有相同的逻辑地址，但是它们所占用的物理内存是不同的(当然，这是操作系统在建立段表的时候就已经确保了)，段表存在的意义就是解决各个程序地址空间不隔离的问题。

- 解决了程序运行的地址不确定的问题

  因为引入了逻辑地址空间，通过段表来建立逻辑地址空间和物理地址空间的映射，对于用户程序，只需要在逻辑地址空间进行编码即可。

- 内存使用效率相比之前的有了很大的改善，程序是以段为单位进行换入换出的，而不是以整个程序为单位。

  

**分段的缺点：**

1. 比较浪费内存，容易产生外部碎片

   

**引入一个问题： 段表何时建立的？**

在进程创建的时候，由内核建立段表，并且设置每个段的基地址，也就是说在进程创建的时候，每个段的物理内存就已经分配好了。



#### 分页

分页的基本方法是把逻辑地址空间等分成固定大小的页，每一页的大小由硬件决定。把物理内存空间分成与页大小相等的若干个存储块，称为页框。

- 引入了分页机制之后，程序员使用的逻辑地址分为两部分，一部分用来表示页号， 另一部分表示页内偏移，而物理地址分成帧号和帧内偏移。

- 硬件是怎么支持分页的？

  ![image-20220709113130706](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220709113130706.png)

  

- 分页的优点：

  其实分段的优点，分页都具备，而且分页改善了分段的缺点，没有了外碎片。

- 分页的缺点：

  会产生内碎片，这个是不可避免的。



**现在大部分的 CPU 基本采用的是分页机制而不是分段机制。**



#### 段页式存储管理

- 用户代码的管理：按照分段式存储管理进行分配

- 内存划分：按照分页式存储管理方案

  

**地址结构：**

![image-20220710115309519](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220710115309519.png)

1. 段号的位数决定了每个进程最多可以分几个段

2. 段内页号位数决定了每个段最大有多少个页

3. 页内偏移量决定了页面大小、内存块(页框)大小是多少



- 硬件是怎么支持段页式存储的？

![image-20220716094341091](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220716094341091.png)





**细节说明**

​		首先 CPU 访问的是逻辑地址0x0040，它首先会根据段号去查段表，得到虚拟地址 0x001040,然后根据虚拟地址的页号去查页表，如果该项的标记位为 1，则 CPU 就可以直接得到物理地址，然后访存， 但如果该项的标记位为 0 ，则会发生缺页中断，操作系统将从物理内存分配一个物理页，然后将该“缺页”从磁盘加载至物理内存中，最后再设置该缺页的虚拟页与物理页的映射关系 ，然后 CPU 会重新访问这个虚拟地址，再次查页表得到物理内存地址，从而进行访存。



**流程图展示**：

![image-20220815211729810](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220815211729810.png)





####  现代操作系统实际采用的内存管理方式

先说结论：现代操作系统实际采用的是**分段+分页相结合的内存管理方式** (段页式内存管理)，这里说的操作系统包括 Linux 和 Windows。但实际上操作系统将段给屏蔽了，(如何屏蔽？下面讲)

我以 Linux 32 位操作系统为例，Linux 内核将各个段的基地址设置为 0x00000000，即，进程的代码段，数据段等其它段都是从0x00000000 开始偏移的，也就是说段内偏移的最大值就是 4G ，与 32 位的操作系统的进程虚拟地址空间为 4G 正好符合。那么，在段页式存储管理中，CPU 访问的地址就不是逻辑地址了，而是虚拟地址，在操作系统屏蔽段之后，进程看到的就是虚拟地址了。



下面我以一个实际例子来说明应用程序是如何在 Linux 系统上跑起来的？

#### 可执行文件是如何被装载的？

在操作系统支持分段，分页机制以及虚拟内存技术之后，一个程序要想真正跑起来，必须要做以下三件事情:

- 创建一个独立的虚拟地址空间，其实就是分配一个页目录。

- 读取可执行文件头，并且建立虚拟地址空间与可执行文件的映射关系

- 将 CPU 的 PC 寄存器设置为可执行文件的入口地址




分段和分页机制上面已经提到过了，那什么是虚拟内存技术呢？

**下面是我摘取的深入理解计算机系统书上的关于虚拟内存的官方定义：**

为了更加有效的管理物理内存并且少出错，现代操作系统提供了一种对主存的抽象概念，叫做虚拟内存。虚拟内存是**硬件异常、硬件地址翻译、主存、磁盘文件和内核软件**的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：

1. 它将主存(物理内存)看成是一个存储在磁盘上的地址空间的高速缓存，在主存只保留活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。
2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。
3. 它保护了每个进程的地址空间不被其它进程破坏。



如果大家确实把上面我提到的分段，分页机制搞明白，理解虚拟内存应该是比较容易的。



**下面我以一个实际的 ELF 文件作为例子，阐述一下可执行文件是怎么被装在至物理内存中，从而跑起来的。**

这里我采用的例子是公司项目的 SdkSidecar 组件，因为这个程序也比较大，作例子比较好讲:	

**第一步，就是内核分配的一个页目录，保存的是虚拟页和物理页的映射关系**，其实就是上面所说的页表，只不过它更加特殊些，保存的是多级页表,至于什么是多级页表，可自行百度。

**第二步，读取可执行文件头，并且建立虚拟地址空间与可执行文件的映射关系**

我们先来看下可执行文件头都包含哪些内容？

1.通过 readelf -h 可执行文件名 命令即可查看，示例如下：

```
xuser@muc-dev-common-001-10-30-6-1:/alidata/cmd$ readelf -h sdkSidecar_mq
ELF Header:
Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
Class: ELF64
Data: 2's complement, little endian
Version: 1 (current)
OS/ABI: UNIX - System V
ABI Version: 0
Type: EXEC (Executable file)
Machine: Advanced Micro Devices X86-64
Version: 0x1
Entry point address: 0xd14e80
Start of program headers: 64 (bytes into file)
Start of section headers: 70695328 (bytes into file)
Flags: 0x0
Size of this header: 64 (bytes)
Size of program headers: 56 (bytes)
Number of program headers: 10
Size of section headers: 64 (bytes)
Number of section headers: 45
Section header string table index: 44
```



上述中有一个重要的一项是：`Start of program headers `，含义是**程序头表的起始地址**，操作系统正是通过这个程序头表来建立虚拟地址空间和可执行文件的映射关系的。这里可以引申出来两个问题：

**第一个问题是操作系统怎样建立虚拟地址空间与可执行文件的映射关系？**

**第二个问题是操作系统为何要建立虚拟地址空间与可执行文件的映射关系？**



要想弄清楚以上问题，我们先来了解一下 ELF 文件：

- 先来看下 SdkSidecar ELF 文件的各个Section (节头表)，也叫做段表, 这里我只列了几个重要的 Section

  ```
  xuser@muc-dev-common-001-10-30-6-1:/alidata/cmd$ readelf -S sdkSidecar_mq
  There are 45 section headers, starting at offset 0x436b9a0:
  
  Section Headers:
  [Nr] Name 	 Type 	  	Address 	Offset 		Size 		EntSize 	Flags 	Link 	Info 	Align
  [14] .text	 PROGBITS 	00d14e80 	00914e80 	011dc5b2 	00000000 	AX 		0 		0 		32
  [16] .rodata PROGBITS 	01ef1440 	01af1440 	006aac80	00000000 	A 		0 		0 		32
  [27] .data   PROGBITS 	0355b000 	02f5b000 	00020220 	00000000 	WA 		0 		0 		32
  [30] .bss    NOBITS 	0364c060 	0304c044 	00384c0 	0000000 	WA 		0 		0 		32
  [31] .other 						0304c044
  [42] .symtab SYMTAB 	00000000 	0304c0a0 	00485508 	00000018 			43 		68620   8
  
  注意: 上面的 .other 字段名是我任意起的，只是为了说明 .bss 并不占用 ELF 可执行文件的空间(从offset 属性便可以看出)，但是占用虚拟地址空间
  
  重要属性列的含义：
  name : 段名
  Address : 段的虚拟地址
  offset : 段在 ELF 文件中的偏移(距离文件头的偏移)
  size : 段的大小
  ```



- 接下来看下 可执行文件的程序头表的内容，这里只列举 2 个重要的项（2个LOAD 页）

```

xuser@muc-dev-common-001-10-30-6-1:/alidata/cmd$ readelf -l sdkSidecar_mq

Elf file type is EXEC (Executable file)
Entry point 0xd14e80
There are 10 program headers, starting at offset 64

Program Headers:
Type 	Offset 		VirtAddr 	PhysAddr 	FileSiz 	MemSiz 		Flags 	Align
LOAD 	0x00000000 	0x00400000  0x00400000 	0x02f59f48	0x02f59f48 	R E 	0x200000 	---代码段
LOAD 	0x02f5ac08 	0x355ac08 	0x0355ac08 	0x000f143c  0x0013a028  RW 		0x200000 	--- 数据段

Section to Segment mapping:
Segment Sections...

02 .interp .note.ABI-tag .note.go.buildid .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .typelink .itablink .gopclntab .eh_frame_hdr .eh_frame

03 .init_array .fini_array .dynamic .got .data .go.buildinfo .noptrdata .bss .noptrbss

属性列的含义
Offset：该段在 ELF 文件中的偏移
VirtAddr：该段在进程虚拟地址空间的起始地址
FileSiz： 该段在 ELF 文件中所占空间的长度
MemSiz： 该段在进程虚拟地址空间所占用的长度

// 接着来看下 几个重要的段占可执行文件的大小
xuser@muc-dev-common-001-10-30-6-1:/alidata/cmd$ size sdkSidecar_mq
text    		data     bss     dec     		hex 		filename
49650857        988220   297944  50937021       3093cbd 	sdkSidecar_mq
```

有两点我们需要知道：

1.在链接器链接的时候，会将相同权限的段合并到一起形成页，然后操作系统在建立可执行文件和虚拟地址空间映射的时候是以页为单位的， Linux 操作系统中页大小为 4K Bytes，合并段的原因就是为了节省内存。

2.操作系统正是通过程序头表建立虚拟地址空间与可执行文件的映射关系的。



- 然后我们再来看下进程的内存映射，这里我只列举了几个重要的段映射，

  **需要说明一点的是程序必须运行起来，才能查看进程的内存映射。**

  1. 进程的内存映射 ：其实就是操作系统建立好的可执行程序与虚拟地址空间的映射关系。
  2. 查看方式 `cat /proc/进程号/maps`

```
xuser@muc-dev-common-001-10-30-6-1:/alidata/cmd$ cat /proc/5248/maps
00400000-0335a000 r-xp 00000000 fc:11 6830208 /mnt1/cmd/sdkSidecar_mq 代码段
0355a000-0355b000 r--p 02f5a000 fc:11 6830208 /mnt1/cmd/sdkSidecar_mq 只读段
0355b000-0364d000 rw-p 02f5b000 fc:11 6830208 /mnt1/cmd/sdkSidecar_mq 数据段
....
```



**第三步：将 CPU 的 PC 寄存器设置为可执行文件的入口地址其实这里说的可执行文件的入口地址。**

其实就是上面可执行文件头里的这一项，`Entry point address` , 这里又引出一个问题？`Entry point address `是main函数的地址吗？这个问题等价于，程序是 从 main 函数开始运行的吗？

其实程序并不是从 main 函数开始运行的 ，操作系统在装载程序之后，首先运行的代码并不是 main 函数，而是执行其它函数代码(被称之为入口函数)，入口函数主要做的其实就是两件事：

- 首先初始化 main 函数执行所需要的环境，包括堆，栈，全局变量，I/O等.
- 等 main 函数执行完毕以后，返回到入口函数，入口函数要进行清理工作，包括全局变量析构，堆和栈的销毁，关闭 I/O等。



**总结：**

下面我画了一个图，这张图只是为让大家能够对 "可执行程序如何装载至内存"有一个整体认识：

![image-20220815212234815](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220815212234815.png)





接下来我来谈下上面遗留的问题：

**操作系统为何要建立虚拟地址空间与可执行文件的映射关系？**

原因其实很简单。在谈答案之前，我先大概总结一下上面的三个步骤：

一个应用程序要想运行起来，必须要完成上面的三个步骤，**分配页目录，建立虚拟地址空间和可执行文件的映射，设置 CPU 的 PC寄存器。**

以上三步可以简单理解为内核将进程创建好了，当内核创建好这个进程之后，CPU 访问的第一条指令的地址是 0x00d14e80 (结合上面的图来看)，假设该虚拟页的页号为 0 ，则 CPU 去查页表发现对应的标记位为 0，这时会发生缺页中断，操作系统将从物理内存分配一个物理页，**然后将该“缺页”从磁盘加载至物理内存中**，最后再设置该缺页的虚拟页号与物理页号的映射关系(其实就是在页表增加一条记录) ，然后 CPU 会重新访问这个虚拟地址，再次查页表得到物理内存地址，拿到物理内存地址之后，CPU 才会从物理内存中取指令和数据，从而执行。

上面提到了缺页中断，当 CPU 去查页表发现对应的标记位为 0，这时会发生缺页中断，操作系统将从物理内存分配一个物理页，**然后将该“缺页”从磁盘加载至物理内存中**，但有个问题，操作系统是怎么知道这个虚拟页在可执行文件中的位置？ 答案其实很明显了，正是因为

建立了虚拟地址空间与可执行文件的映射关系，操作系统才能找到 cpu 访问的虚拟地址对应的虚拟页在可执行文件中的偏移，从而将该虚拟页加载至物理页框中(物理内存中)。



**流程图展示**：

与上面的段页式流程图基本一样，只是去掉了逻辑地址和查段表的步骤。



![image-20220815212041439](C:\Users\33699\AppData\Roaming\Typora\typora-user-images\image-20220815212041439.png)





**操作系统怎样建立虚拟地址空间与可执行文件的映射关系？**

先大概提一下：是通过mmap 建立的，至于细节以后再说。。。

